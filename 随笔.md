# lesson 1-2 
## 算法的核心指标
- 时间
- 空间 
### 分析方法
- 大O表示法
## 什么是算法和数据结构
### 广义
- 数据结构就是指一组数据的存储结构。
- 算法就是操作数据的一组方法。
### 狭义
- 著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。
## 学习算法的好处
- 经典数据结构和算法都是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。
## 数据结构和算法的关系
- 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 两者是相辅相成的不可分隔
## 常见算法和数据结构
- 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
- 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
## 学习目标
- 自身特点
- 适用于解决的问题
- 实际应用场景
- 来历
## 程序员内功
那技术人究竟都需要修炼哪些“内功”呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。
## 算法和数据结构分类
- 如何评价算法的好与坏
- 以数据结构为类,分散算法
  - 数据结构的来历,特点,适用场景
  - 数据结构的相关算法
    - 算法来历,特点
    - 与其他算法类似点.
    - 算法与数据结构 demo 代码
- 基本思想
# lesson 3 - 4 
## 算法解决的问题
- 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。
## 时间空间复杂度分析
- 为了衡量算法的好与坏
- 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。
## 为什么需要复杂度分析？
### 不使用复杂度分析
1. 我们可以通过把代码执行,监控.得到代码最后的准确时间和内存大小 .这种方法叫 "事后统计法".
### 复杂度分析要解决的问题
1. 测试结果非常依赖测试环境: 硬件的不同会对结果产生很大影响. i9 > i3 . 
2. 测试结果受数据规模的影响很大: 1000条数据 和 1000w条数据 制定的算法性能是不同的.
## 大 O 复杂度表示法
1. 假设 读数据-运算-写数据 的效率都一样 为 unit_time . 
2. 没一行代码执行都会使用1个 unit_time .
```Typescript
const l = [1,2,3,3,4,5,6,7,8,9,0]; // 1 unit_time
let result = 0; // 1 unit_time
for ( let i of l) {  // 1 unit_time * l.length
  result += l[i] // 1 unit_time * l.length
}
console.log(result) // 1 unit_time
// 总运行时间为 1 + 1 + 1 * l.length + 1 * l.length + 1
// 总结 代码的效率与 l.length 有关系 即 代码的效率 = l.length 的长度. l.length * 2
// 1 + 1 + 1 * n + 1 * n + 1 = 2n + 3
// 大O : T(n) = O(2n + 3)  => T(n) = O(2n) => T(n) = O(n)
```
```ts 
function cal(n:number) {
  let sum = 0 // 1
  let i = 1 ;  // 1
  let j = 1 ; // 1
  for ( ; i <= n ; ++i) { // 1 * n
    j = 1 ;  // 1 * n
    for(; j<= n ; ++j) { // 1 * n * n
      sum = sum + i * j ; // 1 * n * n
    }
  }
  return sum // 1
}
// 效率总和是  1 + 1 + 1 + 1 * n + 1 * n + 1 * n * n + 1 * n * n + 1
// 简化为 n * (2n + 2) + 4
// 大 O :T(n) = O(n * (2n + 2) + 4) => T(n) = O(n * (2n + 2)) => T(n) = O(n*n)
```
3. 例子中我们可以得到 整个代码的执行时间 和 执行次数成正比 T(n) = f(n) * 每行执行时间 
4. 得到公式 T(n) = O(f(n))
   1. T(n) 表示总执行时间
   2. n 表示执行数据规模
   3. O 表示执行一行数据的效率
   4. f(n) 表示每行执行的次数
5. 大 O 时间复杂度表示法,并不能确定代码运行的准确时间,但可以得到 数据规模增长的变化趋势 所以也叫 渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
6. 因为 要描述 n 的趋势,所以 当 n 变化 恒定增加的 可以忽略 比如 2n 随着 n 变化只是恒定增加.而 n * n 会因为 n 的变化成几何倍数增加
### 分析方式
1. 只关注循环执行次数最多的一段代码 : 大 O 只关注 n 对代码的影响 与 代码的趋势,所以只需要关注有关于 n 的循环即可. 更简化可以只关注循环次数最多的 一段代码即可.
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度 . 抓大放小
  1. 例 1: 100 * n + n * n + 100 => 
     1. 忽略 常量 : T(n) = O(f(n * 100 + n * n))
     2. 当 n > 100 : T(n) = O (f(n * n))
     3. 当 n < 100 : T(n) = O (f(n * 100))
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积. 即循环套循环 = 循环次数  * 循环内的循环次数
  1. 例 1: 循环 n 次, T(n) = O(f(n))
  2. 例 2: 循环 n 次, 每次 循环 n 次  , T(n) = O(f(n) * f(n)) = O (f(n*n))
## 几种常见时间复杂度实例分析
### 多项式量级和非多项式量级
-  多项式量级 : 
   - 以 n 为底数
   - n 方大 算法性能增加 , 但性能比非多项式 好. 
-  非多项式量级:
   - n 不仅仅 可以做底数. 
   - n 放大 算法性能急剧增加
- 比较 n ^ 2 的性能 > n ^ n 的性能
###  常见时间复杂度实例
- 非多项式量级: O(2^n) 和 O(n!)
- 多项式量级:
  - O(1) : 指没有被重复执行的代码的效率 , 即使 是 10条代码, 也可以理解为是 O(1) 因为只执行 1 次
  - O(logn)、O(nlogn) :  
    - 解决的问题: 对数问题  n = 2 ^ x , n = 3 ^ x 的结果是 log(2)n , log(3)n 
    - log(2)n 和 log(3)n 效率如何比较 : log(3)n 比 log(2)n 效率高 . 因为 log(3)n = log(2)n * log(3)2
    - log(2)n 和 log(3)n 为什么都可以表示为 logn : 因为关注的只是 n 和效率的关系.所以 log(2) 和 log(3) 其实是常量的差别,不会对趋势造成影响.
  - O(m+n)、O(m*n)
    - 当有两组不定量时, m , n 这两组值时,我们无法确定 m > n or n < m 所以无法进行去掉不重要的处理. 但是可以通过 * 完成. T1(m) + T2(n) = O(f(m) + g(n)) ; t1(m) + t2(n) = O(f(m) * f(n))
## 空间复杂度分析
- 空间复杂度分析,主要看和 n 相关的代码即可 , 比如 创建一个 n 长的 数组. = O(n)
- 常见的空间有 O(1)、O(n)、O(n2 )
- 空间计算和时间计算是相同的.

## 复杂度 场景分析
一段代码在不同的场景下的复杂度是不一样的.比如 判断一个值在一个数组中的位置. 这个数在 0 和 n 的位置的效率是完全不同的.
### 最好情况复杂度
- 在最理想的情况下的复杂度,比如 判断值在数组中位置时,恰好值在第一个位置.
### 最坏情况复杂度
- 在最坏的情况下的复杂度,比如判断值在数组中位置时,值没有出现在数组中
### 平均情况复杂度
- 因为最好和最坏的情况发生的概率并不大, 所以想要表示平均情况, 需要使用新的概念.平均情况复杂度.
- 群举: 计算平均情况复杂度 = 所有次数 / 最大次数 = n (n + 3) / 2(n + 1)
- 概率统计(加权平均时间复杂度): 给每一个情况增加一个概率 然后统计出效率.具体效率
```ts
const array = new Array(n) ; 
const count = 0;
function insert(val:number) {
  if(count === array.length) {
    let sun = 0 ; 
    for (let i = 0 ; i < array.length ; ++i) {
      sum = sum + array[i];
    }
    array[0] = sum ;
    count = 1 
  }
  array[count] = val ;
  ++count
}
```
# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
## 为什么数组要从 0 开始编号，而不是从 1 开始呢？
因为其实下标是用来移动内存的.第0个其实是移动 0 * 内存大小. 第二个值是 1 * 内存大小.
## 什么是数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
### 数组存储
1. 需要一组连续的内存空间
### 关键点
1. 线性表.
  1. `线性表`: 线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组，链表、队列、栈等也是线性表结构。
  2. `非线性表`: 比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
2. 连续的内存空间和相同类型的数据.
### 优势
1. 随机访问
### 劣势
1. 删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。
2. 随机访问 可能会越界. 即下标不存在
### 工作
#### 创建
寻找一个内存块, 在内存块创建一个长度为10的空间, 内存会分配一个连续的10个的空间给数组.
#### 查询
例如下标是 i , 找到数组对应的内存块 . 用 i * 每个空间的大小. (base_address + i * data_type_size) 找到对应的空间.拿到对应的值.
#### 插入
在 k 的位置插入一个值
1. 将 k 位置腾出, 将 k 之后的数据 后挪.
2. 插入数据
3. 效率为 : O(n)
##### 块排思想
把 k 插入 n 的位置
1. 把 n 的位置内容取出
2. 把 k 插入 n 的位置
3. 把 n 插入 n + 1
4. 效率为 : O(n) , 但是数组旧的顺序被破坏.
#### 删除
把 n 位置的内容删除
1. 找到 n 位置 删除
2. 将 n 位置之后的内容前移1格
3. 效率为 O(n)
##### 标记清除垃圾回收算法
当我们要删除多个数据时候可以使用这种方案.
1. 直接删除 n 个数据
   1. 循环 n 
   2. 找到 第 n 个数据的位置
   3. 删除 数据
   4. 效率: O(n^2)
2. 标记删除 n 个数据
   1. 标记 n 个数据为废弃数据
   2. 创建新的数据.拷贝没有废弃的数据
   3. 替换数组
   4. 效率: O(n)
### 数组和其他类型结构的优势
1. 支持随机访问. 可以通过下标查值.
### 数组结构使用场景
1. 存在遍历的情况
# 06 | 链表（上）：如何实现LRU缓存淘汰算法?
## 链表有什么用
## LRU 缓存淘汰算法
LRU 策略是先进先出策略. 将最久的缓存删除. 所以设计使用单链表. 
1. 默认头节点为最新节点. 
2. 当查询缓存时,依次查询.
3. 查询到要使用的缓存时,将该缓存挪到头缓存.
4. 并删除当前位置缓存.
5. 如果有新缓存进入.判断是否有空间存放
   1. 有空间存放,直接插入头节点
   2. 无空间存放,删除尾节点,插入新缓存到头节点.
- 复杂度为O(n).
- 好处,使用最频繁的缓存,永远在最近的地方.而使用不频繁的缓存会慢慢的被删除.
## 链表的存储结构
1. 不需要连续的空间
2. 通过指针将一组数据串连起来.
## 链表常用结构
### 单链表
- 链表是由一个个 item 组成.
- 每个 item 有两个值 
  - data 数据本身 
  - next 下一个是谁
- 特殊 item
  - 第一个叫头节点 : 记录基地址,通过该节点可以比遍历整个链
  - 最后一个叫尾节点 : 指向 null , 表示链表结束
- 插入 , 删除 ,查找
  - 插入 :
    - 插入内容到某个节点的效率是 O(1) , 但是修改节点的上个节点的 next 效率是 O(n)
  - 删除 : 
    - 不需要移动所有节点只需要处理当时节点的 next 效率 O(1) 
    - 但是修改节点的上个节点的 next 效率是 O(n) 
  - 随机访问: 因为 链表不是有序存储,没有办法通过 下标 * 大小来找,只能遍历 n 个数据得到 ,效率 O(n)
### 循环链表
- 循环链表什么:循环列表与单列表结构基本相同.不同点在于尾节点. 单链表的尾节点指向 头节点. 首尾相连.
- 循环链表比单链表的好处是: 链表尾到链表头比较方便.如果数据具有环型结构特点时，就特别适合采用循环链表
- 经典使用场景:
  - 约瑟夫斯问题 : 有 一个环 有 n 个值, 从第一个值开始,每过两个值删除一个值, 直到剩下最后一个值.
### 双向链表
- 双向链表 和 单向链表的不同点在于 双相链表的 每一个 item 中多存放了一个 prev 记录上一个节点. 
- 双向链表 支持 双向遍历.
- 在存储相同多的数据时, 双向列表占用空间比单向列表多.
- 双向链表 比 单向列表的好处:
  - 以 O(1) 效率取到节点的前后节点.
  - 删除,修改: 给定节点位置时,删除该节点 . 效率只需要 O(1) 因为 知道上下节点 所以不需要查询
  - 查询: 在第一次查询时 记录 位置 P , 在第二次查询时候先通过 P 来判定向后还是向前. 然后 继续查询效率增加 .
## 思想
1. 以空间换时间, 以时间换空间.
2. 因场景来选择 时间重要还是空间重要 进行权衡. 例如缓存,即用空间换时间.
## 链表(双向链表) 和 数组对比
1. 链表 比 数组更耗费内存 , 且容易造成 内存碎片促发垃圾回收
2. 链表的 插入,删除 比数组快
3. 数组的 随机查询 比链表快.
4. 数组不支持动态扩容. ( JavaScript 数组设计)
## 字符串是否是回文字符串,字符串是通过单链表来存储的，那该如何来判断是一个回文串呢
https://leetcode.cn/problems/palindrome-linked-list/submissions/
# 07 | 链表（下）：如何轻松写出正确的链表代码？
## 技巧一：理解指针或引用的含义
指针存放了一个变量的地址. 我们可以通过指针找到变量的地址 -> 找到变量本身.
- p->next = q : p.next 存放了 q 的地址
- p->next = p->next->next : 
  - 操作前: p = p ; p.next = p1; p.next.next = p2 . 
  - 操作中: p.next = p.next.next ; 
  - 操作后: p = p ; p.next = p2; p.next.next = p2.next
  - 结果:原始的 p.next 被删掉了.
## 技巧二：警惕指针丢失和内存泄漏
常见错误
```ts
const x = {next:null};
const p2 = {next:null}
const p1 = {next:p2}
const p = {next:p1}
// 给 p.next 和 p.next.next 之间插入值
/* 
p.next = x
x.next = p.next  // 链断裂,因为 p.next 已经改成了 x
*/
x.next = p.next;
p.next = x;
console.log(p.next.next) 
```
## 技巧三：利用哨兵简化实现难度
哨兵的作用其实是为了解决边界情况.将不通用的个例,归拢成统一. 常用链表查询方法
### 添加
```ts
function add(head,val) {
  if(head == null) {
    head = val
  }
  head.next = key
}
```
### 删除
```ts
function del(head , val ){
  while(head.next.next !== null) {
    if(head.next == val){
      head.next = head.next.next
    }
    head = head.next
  }
  head.next = null;
}
```
## 技巧四：重点留意边界条件处理
常见 链表边界:
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
## 技巧五：举例画图，辅助思考
遇到困难的思考,可以画图解决
## 技巧六：多写多练，没有捷径
- https://leetcode.cn/problems/reverse-linked-list/description/
- https://leetcode.cn/problems/linked-list-cycle/description/
- https://leetcode.cn/problems/merge-two-sorted-lists/submissions/
- https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/
- https://leetcode.cn/problems/middle-of-the-linked-list/submissions/
## 常用操作链表手段
### 虚拟头节点
- 虚拟头节点是创建一个空的链表头,它的 next 指向使用链表.
- 虚拟头节点有两个用途:
  - 保存原始链表,不被破坏
    - 例: 要求返回一个链表 , 而链表是 一个个 item 拼接的. 在拼接的过程中 会频繁的更改列表.此时可以使用一个虚拟头节点保存原始值
  - 保证删除节点操作相同
    - 例: 从后删除某节点,当节点是第一个节点时, 删除逻辑与其他逻辑不同.
### 快慢指针
- 快慢指针用来处理 寻值的位置.
- 快慢指针利用的是 一个值连接下一个值的原理.
- 快慢指针有两种用法
  - A 的位置距离 B 的位置有 n 个距离. 可以将 B 推到 n 的位置,然后 A B 一起推进 
    - 例题: 删除倒数第 n 个值 , 
  - A 的位置是 B 位置的 n 倍, 可以在每一次 遍历时 , 移动另一个位置 n 次.
    - 例题: 寻找链表的中点 ,  判断链表是否是个循环链表
### 反转列表
- 保存 next 
- 更改当前 item 的 next 为上一个 item
- 继续循环 next .
# 08 | 栈：如何实现浏览器的前进和后退功能？
## 栈 结构生活例子 
- 栈结构像一摞盘子. 我们平时拿盘子时往往会拿最上面的第一个.放盘子时也会放在最上面. 不随意从中间抽取盘子. 
## 栈 特性
- 先入后出 , 后入先出.
- 栈是一种“操作受限”的线性表 . 只允许在一段插入和删除.
## 栈和链表,数组的区别
1. 链表,数组可以替代栈 .栈的优势在于 它只能在一端操作. 操作入口少,容易被操控.
## 栈实现
栈有两种实现方式 :
- 顺序栈 : 数组实现
- 链式栈 : 链表实现
### 顺序栈
```ts
function createStack(n){
  const items = new Array(n)
  return {
    push(value){
      items.push(value)
    },
    pop(){
      return items.pop()
    }
  }
}
```
## 栈工作
- 存入值 : O(1) , 因为仅仅是第一个. 即使是顺序栈有复制数组空间的时间,经过分摊以后也是 O(1) 难度.
- 取出值 : O(1) , 因为仅仅是第一个.
## 使用场景
### 浏览器历史记录 
1. a -> b -> c , c 只能回退到 b 不能回退到 a . 
### 函数调用栈
#### 使用场景
1. 有新的函数执行,则推入函数调用栈中. 内存分配空间 . 代码执行. 
2. 当函数执行完毕后, 函数被推出调用栈, 内存销毁.
#### 总结
先入后出的场景下 , 栈的设计可以杜绝其他逻辑篡改内容.
### 栈在表达式求值应用
1. 求值运算的规则是 先乘除 , 后加减 , 从右到左计算. 
2. 设计两个栈, 一个存放数字, 一个存放运算符 . 当遇到 乘除之后有 加减的情况,直接将两个栈进行计算. 得到值之后继续计算.
3. 即 1 + 2 * 3 + 4 === (1 + 2 * 3) + 4 
#### 有括号的计算器
1. 当表达式中存在括号可以用 三个栈结构来处理
   1. A ：存储数字
   2. B ：存储符合
   3. C ：存储当前作用域
2. 当遇到括号时,存储当前的 取出存储 , 进行比对.
数值 + 符号 , 然后清空 AB 存入新值.
### 栈在括号匹配中的应用
1. 一段代码要求 有括号闭合 [] , {} , () . 如果遇到没有闭合的表达式,则报错.
2. 使用一个栈,当遇到 [ { ( 时存储 ,当遇到 )}] 取出存储 , 进行比对. 取出存储 , 进行比对.
## 栈总结
栈是为单一场景准备的单义数据类型. 它服务的是 后进先出的规则. 在使用该规则的场景中使用栈最为合适. 且栈有非常高的密闭性.可以规避很多边界问题.
生活中也有很多例子:
- 空档接龙的纸牌堆.
- 俄罗斯套娃. 
- 箱子包装.

