# lesson 1-2 
## 算法的核心指标
- 时间
- 空间 
### 分析方法
- 大O表示法
## 什么是算法和数据结构
### 广义
- 数据结构就是指一组数据的存储结构。
- 算法就是操作数据的一组方法。
### 狭义
- 著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。
## 学习算法的好处
- 经典数据结构和算法都是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。
## 数据结构和算法的关系
- 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 两者是相辅相成的不可分隔
## 常见算法和数据结构
- 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
- 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
## 学习目标
- 自身特点
- 适用于解决的问题
- 实际应用场景
- 来历
## 程序员内功
那技术人究竟都需要修炼哪些“内功”呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。
## 算法和数据结构分类
- 如何评价算法的好与坏
- 以数据结构为类,分散算法
  - 数据结构的来历,特点,适用场景
  - 数据结构的相关算法
    - 算法来历,特点
    - 与其他算法类似点.
    - 算法与数据结构 demo 代码
- 基本思想
# lesson 3 - 4 
## 算法解决的问题
- 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。
## 时间空间复杂度分析
- 为了衡量算法的好与坏
- 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。
## 为什么需要复杂度分析？
### 不使用复杂度分析
1. 我们可以通过把代码执行,监控.得到代码最后的准确时间和内存大小 .这种方法叫 "事后统计法".
### 复杂度分析要解决的问题
1. 测试结果非常依赖测试环境: 硬件的不同会对结果产生很大影响. i9 > i3 . 
2. 测试结果受数据规模的影响很大: 1000条数据 和 1000w条数据 制定的算法性能是不同的.
## 大 O 复杂度表示法
1. 假设 读数据-运算-写数据 的效率都一样 为 unit_time . 
2. 没一行代码执行都会使用1个 unit_time .
```Typescript
const l = [1,2,3,3,4,5,6,7,8,9,0]; // 1 unit_time
let result = 0; // 1 unit_time
for ( let i of l) {  // 1 unit_time * l.length
  result += l[i] // 1 unit_time * l.length
}
console.log(result) // 1 unit_time
// 总运行时间为 1 + 1 + 1 * l.length + 1 * l.length + 1
// 总结 代码的效率与 l.length 有关系 即 代码的效率 = l.length 的长度. l.length * 2
// 1 + 1 + 1 * n + 1 * n + 1 = 2n + 3
// 大O : T(n) = O(2n + 3)  => T(n) = O(2n) => T(n) = O(n)
```
```ts 
function cal(n:number) {
  let sum = 0 // 1
  let i = 1 ;  // 1
  let j = 1 ; // 1
  for ( ; i <= n ; ++i) { // 1 * n
    j = 1 ;  // 1 * n
    for(; j<= n ; ++j) { // 1 * n * n
      sum = sum + i * j ; // 1 * n * n
    }
  }
  return sum // 1
}
// 效率总和是  1 + 1 + 1 + 1 * n + 1 * n + 1 * n * n + 1 * n * n + 1
// 简化为 n * (2n + 2) + 4
// 大 O :T(n) = O(n * (2n + 2) + 4) => T(n) = O(n * (2n + 2)) => T(n) = O(n*n)
```
3. 例子中我们可以得到 整个代码的执行时间 和 执行次数成正比 T(n) = f(n) * 每行执行时间 
4. 得到公式 T(n) = O(f(n))
   1. T(n) 表示总执行时间
   2. n 表示执行数据规模
   3. O 表示执行一行数据的效率
   4. f(n) 表示每行执行的次数
5. 大 O 时间复杂度表示法,并不能确定代码运行的准确时间,但可以得到 数据规模增长的变化趋势 所以也叫 渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
6. 因为 要描述 n 的趋势,所以 当 n 变化 恒定增加的 可以忽略 比如 2n 随着 n 变化只是恒定增加.而 n * n 会因为 n 的变化成几何倍数增加
### 分析方式
1. 只关注循环执行次数最多的一段代码 : 大 O 只关注 n 对代码的影响 与 代码的趋势,所以只需要关注有关于 n 的循环即可. 更简化可以只关注循环次数最多的 一段代码即可.
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度 . 抓大放小
  1. 例 1: 100 * n + n * n + 100 => 
     1. 忽略 常量 : T(n) = O(f(n * 100 + n * n))
     2. 当 n > 100 : T(n) = O (f(n * n))
     3. 当 n < 100 : T(n) = O (f(n * 100))
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积. 即循环套循环 = 循环次数  * 循环内的循环次数
  1. 例 1: 循环 n 次, T(n) = O(f(n))
  2. 例 2: 循环 n 次, 每次 循环 n 次  , T(n) = O(f(n) * f(n)) = O (f(n*n))
## 几种常见时间复杂度实例分析
### 多项式量级和非多项式量级
-  多项式量级 : 
   - 以 n 为底数
   - n 方大 算法性能增加 , 但性能比非多项式 好. 
-  非多项式量级:
   - n 不仅仅 可以做底数. 
   - n 放大 算法性能急剧增加
- 比较 n ^ 2 的性能 > n ^ n 的性能
###  常见时间复杂度实例
- 非多项式量级: O(2^n) 和 O(n!)
- 多项式量级:
  - O(1) : 指没有被重复执行的代码的效率 , 即使 是 10条代码, 也可以理解为是 O(1) 因为只执行 1 次
  - O(logn)、O(nlogn) :  
    - 解决的问题: 对数问题  n = 2 ^ x , n = 3 ^ x 的结果是 log(2)n , log(3)n 
    - log(2)n 和 log(3)n 效率如何比较 : log(3)n 比 log(2)n 效率高 . 因为 log(3)n = log(2)n * log(3)2
    - log(2)n 和 log(3)n 为什么都可以表示为 logn : 因为关注的只是 n 和效率的关系.所以 log(2) 和 log(3) 其实是常量的差别,不会对趋势造成影响.
  - O(m+n)、O(m*n)
    - 当有两组不定量时, m , n 这两组值时,我们无法确定 m > n or n < m 所以无法进行去掉不重要的处理. 但是可以通过 * 完成. T1(m) + T2(n) = O(f(m) + g(n)) ; t1(m) + t2(n) = O(f(m) * f(n))
## 空间复杂度分析
- 空间复杂度分析,主要看和 n 相关的代码即可 , 比如 创建一个 n 长的 数组. = O(n)
- 常见的空间有 O(1)、O(n)、O(n2 )
- 空间计算和时间计算是相同的.

## 复杂度 场景分析
一段代码在不同的场景下的复杂度是不一样的.比如 判断一个值在一个数组中的位置. 这个数在 0 和 n 的位置的效率是完全不同的.
### 最好情况复杂度
- 在最理想的情况下的复杂度,比如 判断值在数组中位置时,恰好值在第一个位置.
### 最坏情况复杂度
- 在最坏的情况下的复杂度,比如判断值在数组中位置时,值没有出现在数组中
### 平均情况复杂度
- 因为最好和最坏的情况发生的概率并不大, 所以想要表示平均情况, 需要使用新的概念.平均情况复杂度.
- 群举: 计算平均情况复杂度 = 所有次数 / 最大次数 = n (n + 3) / 2(n + 1)
- 概率统计(加权平均时间复杂度): 给每一个情况增加一个概率 然后统计出效率.具体效率
```ts
const array = new Array(n) ; 
const count = 0;
function insert(val:number) {
  if(count === array.length) {
    let sun = 0 ; 
    for (let i = 0 ; i < array.length ; ++i) {
      sum = sum + array[i];
    }
    array[0] = sum ;
    count = 1 
  }
  array[count] = val ;
  ++count
}
```
# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
## 为什么数组要从 0 开始编号，而不是从 1 开始呢？
因为其实下标是用来移动内存的.第0个其实是移动 0 * 内存大小. 第二个值是 1 * 内存大小.
## 什么是数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
### 数组存储
1. 需要一组连续的内存空间
### 关键点
1. 线性表.
  1. `线性表`: 线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组，链表、队列、栈等也是线性表结构。
  2. `非线性表`: 比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
2. 连续的内存空间和相同类型的数据.
### 优势
1. 随机访问
### 劣势
1. 删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。
2. 随机访问 可能会越界. 即下标不存在
### 工作
#### 创建
寻找一个内存块, 在内存块创建一个长度为10的空间, 内存会分配一个连续的10个的空间给数组.
#### 查询
例如下标是 i , 找到数组对应的内存块 . 用 i * 每个空间的大小. (base_address + i * data_type_size) 找到对应的空间.拿到对应的值.
#### 插入
在 k 的位置插入一个值
1. 将 k 位置腾出, 将 k 之后的数据 后挪.
2. 插入数据
3. 效率为 : O(n)
##### 块排思想
把 k 插入 n 的位置
1. 把 n 的位置内容取出
2. 把 k 插入 n 的位置
3. 把 n 插入 n + 1
4. 效率为 : O(n) , 但是数组旧的顺序被破坏.
#### 删除
把 n 位置的内容删除
1. 找到 n 位置 删除
2. 将 n 位置之后的内容前移1格
3. 效率为 O(n)
##### 标记清除垃圾回收算法
当我们要删除多个数据时候可以使用这种方案.
1. 直接删除 n 个数据
   1. 循环 n 
   2. 找到 第 n 个数据的位置
   3. 删除 数据
   4. 效率: O(n^2)
2. 标记删除 n 个数据
   1. 标记 n 个数据为废弃数据
   2. 创建新的数据.拷贝没有废弃的数据
   3. 替换数组
   4. 效率: O(n)
### 数组和其他类型结构的优势
1. 支持随机访问. 可以通过下标查值.
### 数组结构使用场景
1. 存在遍历的情况
# 06 | 链表（上）：如何实现LRU缓存淘汰算法?
## 链表有什么用
## LRU 缓存淘汰算法
LRU 策略是先进先出策略. 将最久的缓存删除. 所以设计使用单链表. 
1. 默认头节点为最新节点. 
2. 当查询缓存时,依次查询.
3. 查询到要使用的缓存时,将该缓存挪到头缓存.
4. 并删除当前位置缓存.
5. 如果有新缓存进入.判断是否有空间存放
   1. 有空间存放,直接插入头节点
   2. 无空间存放,删除尾节点,插入新缓存到头节点.
- 复杂度为O(n).
- 好处,使用最频繁的缓存,永远在最近的地方.而使用不频繁的缓存会慢慢的被删除.
## 链表的存储结构
1. 不需要连续的空间
2. 通过指针将一组数据串连起来.
## 链表常用结构
### 单链表
- 链表是由一个个 item 组成.
- 每个 item 有两个值 
  - data 数据本身 
  - next 下一个是谁
- 特殊 item
  - 第一个叫头节点 : 记录基地址,通过该节点可以比遍历整个链
  - 最后一个叫尾节点 : 指向 null , 表示链表结束
- 插入 , 删除 ,查找
  - 插入 :
    - 插入内容到某个节点的效率是 O(1) , 但是修改节点的上个节点的 next 效率是 O(n)
  - 删除 : 
    - 不需要移动所有节点只需要处理当时节点的 next 效率 O(1) 
    - 但是修改节点的上个节点的 next 效率是 O(n) 
  - 随机访问: 因为 链表不是有序存储,没有办法通过 下标 * 大小来找,只能遍历 n 个数据得到 ,效率 O(n)
### 循环链表
- 循环链表什么:循环列表与单列表结构基本相同.不同点在于尾节点. 单链表的尾节点指向 头节点. 首尾相连.
- 循环链表比单链表的好处是: 链表尾到链表头比较方便.如果数据具有环型结构特点时，就特别适合采用循环链表
- 经典使用场景:
  - 约瑟夫斯问题 : 有 一个环 有 n 个值, 从第一个值开始,每过两个值删除一个值, 直到剩下最后一个值.
### 双向链表
- 双向链表 和 单向链表的不同点在于 双相链表的 每一个 item 中多存放了一个 prev 记录上一个节点. 
- 双向链表 支持 双向遍历.
- 在存储相同多的数据时, 双向列表占用空间比单向列表多.
- 双向链表 比 单向列表的好处:
  - 以 O(1) 效率取到节点的前后节点.
  - 删除,修改: 给定节点位置时,删除该节点 . 效率只需要 O(1) 因为 知道上下节点 所以不需要查询
  - 查询: 在第一次查询时 记录 位置 P , 在第二次查询时候先通过 P 来判定向后还是向前. 然后 继续查询效率增加 .
## 思想
1. 以空间换时间, 以时间换空间.
2. 因场景来选择 时间重要还是空间重要 进行权衡. 例如缓存,即用空间换时间.
## 链表(双向链表) 和 数组对比
1. 链表 比 数组更耗费内存 , 且容易造成 内存碎片促发垃圾回收
2. 链表的 插入,删除 比数组快
3. 数组的 随机查询 比链表快.
4. 数组不支持动态扩容. ( JavaScript 数组设计)
## 字符串是否是回文字符串,字符串是通过单链表来存储的，那该如何来判断是一个回文串呢
https://leetcode.cn/problems/palindrome-linked-list/submissions/
# 07 | 链表（下）：如何轻松写出正确的链表代码？
## 技巧一：理解指针或引用的含义
指针存放了一个变量的地址. 我们可以通过指针找到变量的地址 -> 找到变量本身.
- p->next = q : p.next 存放了 q 的地址
- p->next = p->next->next : 
  - 操作前: p = p ; p.next = p1; p.next.next = p2 . 
  - 操作中: p.next = p.next.next ; 
  - 操作后: p = p ; p.next = p2; p.next.next = p2.next
  - 结果:原始的 p.next 被删掉了.
## 技巧二：警惕指针丢失和内存泄漏
常见错误
```ts
const x = {next:null};
const p2 = {next:null}
const p1 = {next:p2}
const p = {next:p1}
// 给 p.next 和 p.next.next 之间插入值
/* 
p.next = x
x.next = p.next  // 链断裂,因为 p.next 已经改成了 x
*/
x.next = p.next;
p.next = x;
console.log(p.next.next) 
```
## 技巧三：利用哨兵简化实现难度
哨兵的作用其实是为了解决边界情况.将不通用的个例,归拢成统一. 常用链表查询方法
### 添加
```ts
function add(head,val) {
  if(head == null) {
    head = val
  }
  head.next = key
}
```
### 删除
```ts
function del(head , val ){
  while(head.next.next !== null) {
    if(head.next == val){
      head.next = head.next.next
    }
    head = head.next
  }
  head.next = null;
}
```
## 技巧四：重点留意边界条件处理
常见 链表边界:
- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？
## 技巧五：举例画图，辅助思考
遇到困难的思考,可以画图解决
## 技巧六：多写多练，没有捷径
- https://leetcode.cn/problems/reverse-linked-list/description/
- https://leetcode.cn/problems/linked-list-cycle/description/
- https://leetcode.cn/problems/merge-two-sorted-lists/submissions/
- https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/
- https://leetcode.cn/problems/middle-of-the-linked-list/submissions/
## 常用操作链表手段
### 虚拟头节点
- 虚拟头节点是创建一个空的链表头,它的 next 指向使用链表.
- 虚拟头节点有两个用途:
  - 保存原始链表,不被破坏
    - 例: 要求返回一个链表 , 而链表是 一个个 item 拼接的. 在拼接的过程中 会频繁的更改列表.此时可以使用一个虚拟头节点保存原始值
  - 保证删除节点操作相同
    - 例: 从后删除某节点,当节点是第一个节点时, 删除逻辑与其他逻辑不同.
### 快慢指针
- 快慢指针用来处理 寻值的位置.
- 快慢指针利用的是 一个值连接下一个值的原理.
- 快慢指针有两种用法
  - A 的位置距离 B 的位置有 n 个距离. 可以将 B 推到 n 的位置,然后 A B 一起推进 
    - 例题: 删除倒数第 n 个值 , 
  - A 的位置是 B 位置的 n 倍, 可以在每一次 遍历时 , 移动另一个位置 n 次.
    - 例题: 寻找链表的中点 ,  判断链表是否是个循环链表
### 反转列表
- 保存 next 
- 更改当前 item 的 next 为上一个 item
- 继续循环 next .
# 08 | 栈：如何实现浏览器的前进和后退功能？
## 栈 结构生活例子 
- 栈结构像一摞盘子. 我们平时拿盘子时往往会拿最上面的第一个.放盘子时也会放在最上面. 不随意从中间抽取盘子. 
## 栈 特性
- 先入后出 , 后入先出.
- 栈是一种“操作受限”的线性表 . 只允许在一段插入和删除.
## 栈和链表,数组的区别
1. 链表,数组可以替代栈 .栈的优势在于 它只能在一端操作. 操作入口少,容易被操控.
## 栈实现
栈有两种实现方式 :
- 顺序栈 : 数组实现
- 链式栈 : 链表实现
### 顺序栈
```ts
function createStack(n){
  const items = new Array(n)
  return {
    push(value){
      items.push(value)
    },
    pop(){
      return items.pop()
    }
  }
}
```
## 栈工作
- 存入值 : O(1) , 因为仅仅是第一个. 即使是顺序栈有复制数组空间的时间,经过分摊以后也是 O(1) 难度.
- 取出值 : O(1) , 因为仅仅是第一个.
## 使用场景
### 浏览器历史记录 
1. a -> b -> c , c 只能回退到 b 不能回退到 a . 
### 函数调用栈
#### 使用场景
1. 有新的函数执行,则推入函数调用栈中. 内存分配空间 . 代码执行. 
2. 当函数执行完毕后, 函数被推出调用栈, 内存销毁.
#### 总结
先入后出的场景下 , 栈的设计可以杜绝其他逻辑篡改内容.
### 栈在表达式求值应用
1. 求值运算的规则是 先乘除 , 后加减 , 从右到左计算. 
2. 设计两个栈, 一个存放数字, 一个存放运算符 . 当遇到 乘除之后有 加减的情况,直接将两个栈进行计算. 得到值之后继续计算.
3. 即 1 + 2 * 3 + 4 === (1 + 2 * 3) + 4 
#### 有括号的计算器
1. 当表达式中存在括号可以用 三个栈结构来处理
   1. A ：存储数字
   2. B ：存储符合
   3. C ：存储当前作用域
2. 当遇到括号时,存储当前的 取出存储 , 进行比对.
数值 + 符号 , 然后清空 AB 存入新值.
### 栈在括号匹配中的应用
1. 一段代码要求 有括号闭合 [] , {} , () . 如果遇到没有闭合的表达式,则报错.
2. 使用一个栈,当遇到 [ { ( 时存储 ,当遇到 )}] 取出存储 , 进行比对. 取出存储 , 进行比对.
## 栈总结
栈是为单一场景准备的单义数据类型. 它服务的是 后进先出的规则. 在使用该规则的场景中使用栈最为合适. 且栈有非常高的密闭性.可以规避很多边界问题.
生活中也有很多例子:
- 空档接龙的纸牌堆.
- 俄罗斯套娃. 
- 箱子包装.
# 09 | 队列：队列在线程池等有限资源池中的应用
## 什么是队列 (queue)
队列就似乎排队买票. 
## 队列的特性
- 先入先出.
- enqueue(入) and dequeue(出)
## 队列实现
### 单数组单标记 (顺序队列)
1. 以数组实现 , 标记记录最有一位下标
   1. 取: 从0位置取
   2. 存: 以最后一位下标存.
2. 当 存储内容 > 下标存储 . 存 -> 移动位置到头部 -> 存
### 单数组,双标记 (环形队列)
1. 以数组实现数据存储 ,标记记录 两个下标. 开始 和 结束
   1. 取: 头坐标取
   2. 存: 
      1. 方案1:当尾坐标 === 数组长度 ,则切换到头坐标存.
      2. 方案2:
         1. 尾坐标一直 ++ , 
         2. (尾坐标 + 1 )%  数组长度  === 头坐标时.
## 队列操作
- 入队 enqueue : O(1) 
- 出队 dequeue : O(1)
## 阻塞队列
阻塞队列相当于 仓库 .
- 取 : 当仓库有内容时候可以取
- 存 : 当仓库有空位时候可以存.
## 并发队列
- 用来解决1个内容被多个线程同时更改.
- a,b,c 同时更改 变量 c . 则 c 可能会被覆盖
- a,b,c 更改变量 c . 进入 队列进行排队 . 变量 c 根据队列更改顺序一一更改 .
## 无界队列
- 利用链表实现,没有上限.
## 有界队列
- 有数量限制,每次只能存放数量内的值.超出则拒绝访问.
# 10 | 递归：如何用三行代码找到“最终推荐人”？

## 给定一个用户 ID，如何查找这个用户的“最终推荐人”？
## 递归是什么
- 递归是一种应用非常广泛的算法（或者编程技巧
- 递归分为两个阶段
  - 递: 去求知是递
  - 归: 返回的过程是归.
## 递归公式 
```
f(n) = f(n - 1) + 1 , f(1) = 1;
```
f(n) 是最终结果 , f(n - 1) 是要递归的次数. +1 是因为本身要加 1.
## 使用递归需要满足的条件
###  一个问题的解可以分解为几个子问题的解
一个大问题可以拆解成几个小问题.  (数据规模小的问题.) 
### 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
因为递归本身就是调用自己. 所以需要思路和自己完全相同才可以.
### 存在递归终止条件
递归必须有终止条件的条件, 否则会一直循环下去造成死循环.
### 总结
递归是一个思路多次使用的技巧, 所以要求每个递归的数据符合思路. 而且递归需要一个终止条件. 否则递归毫无意义.
## 如何编写递归代码
- 找到递归逻辑
  - 递: 找到可重复逻辑 
  - 归: 找到终止条件 
- 将可重复逻辑导入函 , 进行递归.
## 递归难点
1. 不要试图理解递归的所有逻辑.而只了解可重复逻辑的一个扣.即可,只关注下一步.
2. 递归要警惕惕堆栈溢出 必须要设置 归的条件.
   1. 在数据规模小的情况下 可以设置阀值 , 但不要动态获取阀值.
   2. 警惕写复杂的递归逻辑 . 那会使用更多的空间和循环.
3. 递归要警惕重复计算
   1. 如果递归的值会有重复现象,可以通过保存结果来为 递归加速
## 递归的时间复杂度
- 递归往往是会处理 1 + 1 数据 . 效率 其实其实是 O(n)
## 调试递归
1.打印日志发现，递归值。
2.结合条件断点进行调试。
# 11 | 排序（上）：为什么插入排序比冒泡排序更受欢迎？
## 排序法分类
| 排序算法       | 时间复杂度 | 是否基于比较 |
| -------------- | ---------- | ------------ |
| 冒泡,插入,选择 | o(n^2)     | 是           |
| 快排,归并      | o(nlogn)   | 是           |
| 桶,技数,基数   | o(n)       | 否           |
## 如何分析一个排序算法
- 排序算法的执行效率
   - 最好情况,最坏情况,平均情况时间复杂度.
      - 原因: 区分算法在不同的情况下的复杂度.
      - 标准:排序数据是否有序 
        - 无序
        - 接近有序
        - 有序
   - 时间复杂度的系数、常数 、低阶
     - 系数 : 3n , 4n 中的 3 , 4 就是 系数, 表示与 未知数有关系的数.
     - 常数 : 指规定的数量与数字 , 常量 ( 一般情况下在数量级小的时候需要特别关注.) 
     - 低阶 : 
   - 比较次数和交换（或移动）次数
     - 在分析算法执行效率的过程中需要考虑, 比较的效率,元素移动交换的效率. 
- 排序算法的内存消耗
- 排序算法的稳定性
  - 如果两个值相同,则要保证他俩的顺序不变.因为 比较对象可能是两个对象而不仅仅是数.
## 冒泡排序
- 冒泡排序每一次循环必须解决一个元素的准确位置. 比如 第 2 位
- 冒泡排序只会操作相邻的两个数据, 每次冒泡都会对相邻的两个元素进行比较,如果不满足条件,就让他俩交互.
- 一次冒泡会至少一个元素移动到它应该在的位置,重复 n 次 就可以完成的将这个数据排序到合适的位置.
- 排序所有值需要移动 n * n 次 . 
```ts
const demo1 = [8, 2, 3, 4, 5, 6, 2, 34, 4, 5, 6, 7, 8, 2, 2].map((value, index) => ({
  index, value
}))
// bubbling
function bubbling(arr) {
  let b = 0
  for (let i = 0; i < arr.length - 1; i++) {
    // 两人比个 第一个个头大就往后坐.
    if (arr[i].value > arr[i + 1].value) {
      const v = arr[i]
      arr[i] = arr[i + 1]
      arr[i + 1] = v;
      b++;
    }
  }
  // 比到没有换过一次座位结束
  return !b ? arr : bubbling(arr)
}
console.log(bubbling(demo1))
```
### 分析
- 冒泡排序法的效率
  - 满有序度 : O(1) 
  - 满逆序度 : O(n * (n - 1) / 2)
  - 平均效率 : O(n * (n - 1) / 4)  
### 冒泡排序优化
1. 当一次排序完全没有值需要移动,则可以终止排序. 数据已经是完全有序的数据.
## 有序度 和 逆有序度
- 有序度是指两个比较值 是符合需求条件的.而逆有序度值的是两个值不符合条件.
- 有序度的多少直接影响排序的效率.
- 排序就是将一个逆有序度的数据改变为有序度的数据.
### 概念
- 有序度: 表示完全按顺序来的数据
- 满有序度: 所有数据比较都有序的数据就是满有序度数据.
- 逆序度: 满有序度 - 有序度 
## 插入排序法
- 插入排序发更关注 元素和元素之间的比较,而非准确的位置. 当所有节点都排序完毕后,才知道准确位置.
- 插入排序分成两个部分 
  - 比较 : 一次比较会对两个值进行比较,直到找到最终结果
  - 插入 : 插入会将一个值插入它该去的地方.
```ts
const demo2 = [34, 1, 2, 3, 4, 5, 6, 2, 34, 4, 5, 6, 7, 8, 2, 2].map((value, index) => ({
  index, value
}))

// insertion
function insertion(arr = [], index = 1) {
  const thisValue = arr[index]; // 获取当前值
  // 在队伍中找最适合她的位置
  for (let i = 0; i <= index; i++) {
    // 找到位置
    if (arr[i].value > thisValue.value) {
      // 让她后面的人都往后坐一排
      for (let c = index; c > i; c--) {
        arr[c] = arr[c - 1]
      }
      // 坐到空位置上.
      arr[i] = thisValue
      break
    }
  }
  console.log(arr)
  return index + 1 === arr.length ? arr : insertion(arr, index + 1)
}
console.log(insertion(demo2))
```
### 分析
- 插入排序法的效率
  - 满有序度: O(1)
  - 满逆序度 : O(n^2)
  - 平均效率 : O(n^2)  
- 插入排序法
  - 是一种稳定算法,因为他是从左到右依次排序
# 选择排序
- 选择排序与插入排序有点类似, 分为两部分.有序区和无序区.
  - 有序区: 存放已排序好的内容
  - 无序区: 存放其他内容.
- 选择排序与插入排序的区别在于 , 选择排序是先在无序区找到最小的值, 按照顺序排序.
- 选择排序的核心在于 有一个座位,选择最适合的人坐.
### 分析
- 选择排序法效率
  - 满有序度: O(n^2) 
  - 满逆序度 : O(n^2) 
  - 平均效率:O(n^2)
- 选择排序法
  - 不是一种稳定排序法 , 因为会有位置交换的逻辑.所以会导致位置错误.
```ts
const demo2 = [9,8,7,6,5,4,3,2,1,1].map((value, index) => ({
  index, value
}))

// Select
function select(arr = []) {
  for ( let i = 0 ; i < arr.length ; i ++) {
    // 寻找最美的她
    let now = i ; 
    for( let c = i ; c < arr.length ; c ++) {
      if(arr[now].value > arr[c].value){
        now = c ;
      }
    }
    // 换位置
    let v =arr[i]
    arr[i] = arr[now]
    arr[now] = v;
  }
  console.log(arr)
}
select(demo2)
```
# 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？ 
## 分治思想
1. 将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。
2. 排序一串数据的核心在于 排序两个数据.
## 归并排序
将给一串数据排序, 变成将两个有序数据合并.
### 实现思路
归并算法的思路是递归
- 递归结束点 : 当前递归的 list 中只有一个值. 
- 递归操作:如果有两个值则,进行双数组合并.
```ts
const demo2 = [10,9,8,7,6,5,4,3,2,1,8].map((value, index) => ({
  index, value
}))

let dd = 0
// merger
function run(arr = []) {
  split(0, arr.length - 1)
  console.log(arr)
  function split(start, end) {
    // 拆
    if (start === end) {
      return
    }
    console.log(1)
    const middle = Math.floor((start + end) / 2) // 返回中点具体是多少无所谓的.
    split(start, middle)
    split(middle + 1, end)
    // 合
    merge(start, middle, end)
  }
  function merge(start, middle, end) {
    // 竞争上岗
    const r = [];
    let first = start; // 第一个指针
    let last = middle + 1 // 第二个指针
    while (first <= middle || last <= end) {
      dd = dd + 1;
      if (first <= middle) {
        if (last > end || arr[first].value <= arr[last].value) {
          r.push(arr[first])
          first = first + 1;
        }
      }
      if (last <= end) {
        if (first > middle || arr[last].value < arr[first].value) {
          r.push(arr[last])
          last = last + 1;
        }
      }
      if (dd % 5000 === 0) {
        debugger
      }
    }
    // 排队上岗
    for (let i = start; i <= end; i++) {
      arr[i] = r.shift();
    }
  }
}
run(demo2)
```
### 性能分析
- 稳定算法
  - 归并是一种稳定算法.在 merge 中设置 first 优先即可.
- 时间复杂度
  - 归并是利用递归来将一组数据分解成多组数据. 进行最小单位的处理,所以最小单位的时间是:
    - 中断条件 -> 数组中为1个值直接返回 -> 时间复杂度为 常量 C
    - 递归下去 -> 
      - 将数据分为两部份进行递归 -> 2 * T(n / 2)
      - 将两个数据合并成一个 -> n 
      - 总结为 -> 2 * T(n / 2) + n
  - 最小步骤的时间复杂度是 2 * T(n / 2) + n 那循环起来就是这样的
    - 增加一次递归 2^2 * T(n / 2^2) + n * 2 
    - 增加一次递归 2^3 * T(n / 2^3) + n * 3 
    - 增加k次递归 2^k * T(n/2^k) + k * n
  - 求 k 值 T(n) = 2^k * T(n/2^k) + k * n 
    - 当 n = 1 的时候 T(n) = T(n/2^k) 
    - k = log^2 * 1
    - 所以 递归的次数是 log^2 * n
    - 时间复杂度 = log^2 * n + Cn 
    - O : nlogn
- 空间复杂度
  - 因为每一次递归都要创建一个空数组来合并两个数组.所以每次递归会常见O(n)大小的空间.
  - 而函数每次执行完毕一个才会执行第二个,所以一直只会有 O(n) 的空间
## 快速排序
### 快速排序思路
1. 快排和归并都使用了分治思想. 一种从地层进行 合并 , 一种从上层进行分组
2. 块排的递归单片
  1. 递归结束条件: 开始点 - 结束点 有 2个值.
  2. 递归的操作:
     1. 找一个中间点
     2. 排序
     3. 递归
```ts
const demo2 = [1,2,3,4,111,22333,444,555,667,2234567,10, 9, 8, 7, 6, 5, 4, 3, 2, 1].map((value, index) => ({
  index, value
}))
let i = 0
test(demo2)
console.log(demo2)
function test(arr = []) {
  recursion(0, arr.length - 1)
  function recursion(start, end) {
    // 寻找一个基点进行排序
    let pivot = end;
    // 进行排序
    let boundary = -1;
    for (let i = start; i <= end - 1; i++) {
      // 遇到比自己大的点重新设计分界点, 此处其实是新的第一个基点的位置
      if (arr[i].value > arr[pivot].value && boundary === -1) {
        boundary = i;
      } else if (arr[i].value < arr[pivot].value) {
        // 交换处理 
        if (boundary !== -1) {
          let v = arr[i];
          arr[i] = arr[boundary]
          arr[boundary] = v;
          boundary++;
        }
      }
    }
    // 如果有新的分界线, 说明 点被移动了. 则需要重新设置分界线 . 这也是块排为什么不是稳定算法的一个点.
    if (boundary !== -1) {
      let v = arr[boundary];
      arr[boundary] = arr[pivot];
      arr[pivot] = v;
      pivot = boundary
    }
    // 处理后
    start < pivot - 1 && recursion(start, pivot - 1)
    pivot + 1 < end && recursion(pivot + 1, end)
  }
}
```
### 快速排序性能分析
1. 快排没有在执行中创建额外的空间所以是一种原地排序.
2. 快排因为通过换位来处理顺序,所以是一种不稳定排序.
3. 快排的时间复杂度: O(nlogn) 与归并相同 但是在最坏的情况下需要 1个1个的排出是 n^2 效率

# 13 | 线性排序：如何根据年龄给100万用户数据排序？
## 桶排序
### 设计思路
- 桶排序核心思路在于先根据 大小关系分类成多个桶,然后在每个桶中进行快排 . 当 桶的数量无限接近 数据的数量时时间效率就会变成 O(n) 
- 桶排序针对的数据是 
  - 可以根据大小划分桶
  - 每个桶的数据都很均匀.
- 桶排序和快排有一些类似. 快排做的最多的事情在于把数据分成多个桶. 然后每个桶再细化.
- 
### 效率
- T(n) = O(m * n/m * log n/m) -> n === m -> O(m * 1 * log1) -> O(m) -> O(n)
### 桶排序要解决的问题
桶排序解决最大的问题在于快排必须要将所有数据加载到内存中才进行排序.而桶排序是将大量数据分成小部分进行快排.本身价值在于降低内存压力
## 计数排序
1. 计数排序法和桶排序法类似. 都是先分组再排序.而计数排序的颗粒度更下.每个桶只有1个数.
2. 计数排序法叫计数排序的原因在于他的算法:
   1. 计算每个值在数据中出现的次数
   2. 根据出现次数得到每个值出现的 index . 
   3. 根据 index + 值进行排序
3. 计数排序的使用场景
   1. 用来排序的值必须是 整数或映射表
   2. 排序的值必须 > 种类.
```ts
const A = [2, 5, 3, 0, 2, 3, 0, 3].map((value, index) => ({
  index, value
}))

// 计数排序法 . 
function sort(arr) {
  const C = new Array(arr.length).fill(0,0,arr.length);
  // 计数
  for (let i = 0; i < arr.length; i++) {
    C[arr[i].value] === undefined && (C[arr[i].value] = 0);
    C[arr[i].value]++;
  }
  console.log(C)
  // 计数 + 
  for ( let i = 1 ; i < C.length ; i++) {
    C[i] = C[i] + C[i - 1]
  }
  console.log(C)
  const R = new Array(arr.length)
  // 创不世之功
  for ( let i = arr.length - 1 ; i >= 0 ; i --){
    C[arr[i].value] --;
    R[C[arr[i].value]] = arr[i];
  }
  console.log(R);
}
sort(A)
```
### 计数排序法效率
1. 计数排序法是一种稳定排序
2. 计数排序发是一种不原地排序
3. 计算排序法的时间复杂度
   1. 1n: 排序计数
   2. 2n: 计数 +
   3. 3n: 根据计数排序
4. O表示 O(n)
## 基数排序
1. 基数排序是一种以多纬度进行排序的方法. 当排序条件可以被拆分时,可以使用基数排序.
2. 基数排序的原理在于将条件,拆成多个小条件,然后比较小条件
```ts
const demo = [
  111, 222, 333, 444, 5553, 3, 2, 2, 2, 11, 111, 3333, 44445, 64534234, 2223424132, 64562, 432432
].map((value, index) => ({ value, index }))

// 排序
sort(demo)
function sort(arr = []) {
  let place = 0; // 比较的位
  while (true) {
    const barrel = Array(10).fill(0, 0, 10);
    for (let i = 0; i < arr.length; i++) {
      const key = String(arr[i].value)
      const p = key[key.length - 1 - place] || 0;
      barrel[p] = barrel[p] + 1;
    }
    if (barrel[0] === arr.length) {
      break
    }

    for (let i = 1; i < barrel.length; i++) {
      barrel[i] = barrel[i] + barrel[i - 1]
    }
    console.log(barrel)
    const result = []
    for (let i = arr.length - 1; i >= 0; i--) {
      const key = String(arr[i].value)
      const p = key[key.length - 1 - place] || 0;
      result[--barrel[p]] = arr[i]
    }
    arr = result;
    place++
  }
  console.log(arr)
}
```
### 基数排序法效率
1. 基数排序计数排序法是一种稳定排序
2. 基数排序发是一种不原地排序
3. 基数排序法的时间复杂度
   1. 基数排序法是根据比较条件的多个纬度进行计算的 (和计算标准有关系)
      1. 1n: 排序计数
      2. 2n: 计数 +
      3. 3n: 根据计数排序
4. O表示 O(n)
## 题目
```ts
const demo = ['D', 'a', 'F', 'B', 'c', 'A', 'z']


sort(demo)
function sort(arr = []) {
  let j = -1;
  for (let i = 0; i < demo.length; i++) {
    if (!/^[a-z]+$/.test(arr[i]) && j === -1) {
      j = i
    } else if (/^[a-z]+$/.test(arr[i])) {
      let v = arr[i];
      arr[i] = arr[j];
      arr[j] = v;
      j++;
    }
  }
  console.log(arr)
}
```
# 14 | 排序优化：如何实现一个通用的、高性能的排序函数？

## 如何选择合适的排序算法 ? 
- 线性排序算法: 复杂度低 , 适用场景特殊 . 不适合作为通用排序函数
- O(nlogn)排序算法: 归并 和 快排
  - 归并 因为使用内存较大, 所以快排变成了首选
## 优化快排
### 合理的选择分区点
1. 理想状态 : 被分区点分开的两个区,数量差不多.
2. 方法
   1. 三数取中法 : 从数据的 前,中,尾 各取一个数,然后取这3个数中的中间数 . 如果数据太多, 可以采用 5 数, 10 数
   2. 随机法: 从数据中随机拿一个数字来做界值.
### 递归过深导致堆栈溢出
1. 过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。
2. 一旦递归过深，超过了我们事先设定的阈值，就停止递归
## 通用排序
1. 不是 n^n 的效率一定大于 nlogn . 当数据规模小的时候使用 n^n 的效率更高.
2. 守卫看似只是少了一个判定,但在循环中运行. 判定一次会放大到 n 倍.
## 总结
1. 适当的规模使用适当的算法.
2. 能少在循环中做事,就少做.
3. 优化递归过深就是使用循环来代替递归.

# 15 | 二分查找（上）：如何用最省内存的方式实现快速查找功能？
## 二分查找思路
- 先决条件: 二分算法建立在有序数组上. 
- 二分的操作: 分治思想 , 取中间数 -> 比较大小 -> 在包含结果的一边继续取中间数 -> 比较大小.
## 二分效率
- 二分的效率是 O(logn)
- 公式  
    - n / 2 + n / 2 / 2 + n / 2^k 
    - 当 n = 1 时 n/2k=1 k = log2n
    - 所以二分要递归 log2n 次. 
    - 大O 表示 logn
## 效率之争
logn > n > n^n
## 写法
### 循环
```ts
// 在数组中查询一个值是否存在

// 准备测试用例
const arr = new Array(100)
arr[0] = 1;
for (let i = 1; i < arr.length; i++) {
  arr[i] = arr[i - 1] + Math.floor(Math.random() * 10)
}

// 在数组中寻找值

// 循环版本
hasNum(arr, arr[13])
function hasNum(arr, num) {
  console.log(JSON.stringify(arr))
  let start = 0;
  let end = arr.length - 1;
  let i = 0;
  while (end >= start) {
    i++;
    if (i > 100) {
      debugger
    }
    let middle = start + ((end - start) >> 1);
    if (arr[middle] == num) {
      console.log('找到了', middle)
      return
    } else if (arr[middle] < num) {
      start = middle + 1;
    } else {
      end = middle - 1;
    }
  }
  console.log('没有找到😐')
}
```
### 递归
```ts
// 在数组中查询一个值是否存在

// 准备测试用例
const arr = new Array(100)
arr[0] = 1;
for (let i = 1; i < arr.length; i++) {
  arr[i] = arr[i - 1] + Math.floor(Math.random() * 10)
}

// 在数组中寻找值

// 递归版本
hasNum(arr, 0, arr.length - 1, 122)
function hasNum(arr, start, end, num) {
  const m = start + ((end - start) >> 1)
  if (arr[m] === num) {
    console.log('孩子找到了', m)
    return
  }
  if (start >= end) {
    console.log('没有噢')
    return
  }
  if (arr[m] < num) {
    hasNum(arr, m + 1, end, num)
  } else {
    hasNum(arr, start, m - 1, num)
  }
}
```
## 二分用在哪里
1. 用在 有序数组中
2. 用在 大数量级数据中
3. 用在 比较条件复杂的比较中
4. 用在 可以支持连续空间 > 数组使用空间的 数量级中.
## 二分解平方
```ts
function sqrt(a, p) {
  let b = Number(1 + (new Array(p - 1).fill(0, 0, p - 1)).join(''))
  let b2 = Number(1 + (new Array(Math.floor(p / 2)).fill(0, 0, Math.floor(p / 2))).join(''))
  a = a * b
  let x = 1.0;
  let check = 0;
  do {
    x = (a / x + x) / 2;
    check = x * x - a
  } while ((check >= 0 ? check : -check) > 0)
  return x / b2
}
sqrt(25, 5)
```
# 16 | 二分查找（下）：如何快速定位IP对应的省份地址？
## 取数据中第一个出现的值
```ts
function hasNum(arr, start, end, num) {
  let m = start + ((end - start) >> 1)
  if (arr[m] === num) {
    if (m > 0 && arr[m - 1] !== num) {
      // 发现这个值不是第一个则继续搞
      m++;
    } else {
      // 搞定
      console.log('孩子找到了', m)
      return
    }
  }
  if (start >= end) {
    console.log('没有噢')
    return
  }
  if (arr[m] < num) {
    hasNum(arr, m + 1, end, num)
  } else {
    hasNum(arr, start, m - 1, num)
  }
}

```
```ts
const num = [1, 2, 3, 4, 5, 8, 8, 8, 9, 19]

hasNum(num, 0, num.length - 1, 8)
function hasNum(arr, start, end, num) {
  let m = start + ((end - start) >> 1)
  if (start >= end) {
    if (arr[start] === num && start > end) {
      console.log(start)
    } else {
      console.log('没有噢')
    }
    return
  }
  if (arr[m] < num) {
    hasNum(arr, m + 1, end, num)
  } else {
    hasNum(arr, start, m - 1, num)
  }
}
```
## 变体二：查找最后一个值等于给定值的元素
```ts
const num = [1, 2, 3, 4, 5, 8, 8, 8, 9, 19]

hasNum(num, 0, num.length - 1, 8)
function hasNum(arr, start, end, num) {
  let m = start + ((end - start) >> 1)
  if (arr[m] === num) {
    if (m < arr.length && arr[m + 1] === num) {
      // 发现这个值不是第一个则继续搞
      m++;
    } else {
      // 搞定
      console.log('孩子找到了', m)
      return
    }
  }
  if (start >= end) {
    console.log('没有噢')
    return
  }
  if (arr[m] < num) {
    hasNum(arr, m + 1, end, num)
  } else {
    hasNum(arr, start, m - 1, num)
  }
}
```
## 变体三：查找第一个小于给定数的元素
```ts
const num = [1, 2, 3, 4, 5, 8, 8, 8, 9, 19]

hasNum(num, 0, num.length - 1, 8)
function hasNum(arr, start, end, num) {
  let m = start + ((end - start) >> 1)
  if (start >= end) {
    console.log('没有噢')
    return
  }
  if (arr[m] > num) {
    if (arr[m] > num && arr[m - 1] <= num) {
      console.log('孩子找到了', m)
      return
    }
    hasNum(arr, start, m - 1, num)
  } else {
    hasNum(arr, m + 1, end, num)
  }
}

```
## 查找最后一个小于等于给定值的元素

```ts
const num = [1, 2, 3, 4, 5, 8, 8, 8, 9, 19]

hasNum(num, 0, num.length - 1, 8)
function hasNum(arr, start, end, num) {
  let m = start + ((end - start) >> 1)
  if (start >= end) {
    console.log('没有噢')
    return
  }
  if (arr[m] > num) {
    if (arr[m] > num && arr[m - 1] <= num) {
      console.log('孩子找到了', m - 1)
      return
    }
    hasNum(arr, start, m - 1, num)
  } else {
    hasNum(arr, m + 1, end, num)
  }
}

```
# 17 | 跳表：为什么Redis一定要用跳表来实现有序集合？
## 跳表
- 支持快速 插入 , 删除 , 查询 
- 跳表是在链表的基础上实现二分.
- 跳表的实现是以空间换时间
## 跳表效率
- 查询时间复杂度: 跳表的时间效率是 O(nlogn)
- 空间: 跳表的空间复杂度是 O(n)
## 跳表实现
- 链表支持快速插入 ,删除. 而不支持快速查询.
- 跳表在链表的基础上,通过二分思想,在链表的基础上,做了一个二分索引结构.
- 查询时从上向下一级一级缩小范围查询 = 二分. 
## 跳表的新问题
- 跳表是通过索引来管理整个链表的.
## 操作
- 增 -> 
  - 查: 从上向下查询 -> 查到 item.value !== null
  - 新增: 创建, 修改 左右指针
  - 随机数: 设置 up 执行 新增 
- 删 -> 
  - 查: 从上向下查询 -> 查到 item.value !== null
  - 删: item 左右 item 修改 
  - 向上查 item 执行删操作
- 改 ->  
  - 查: 从上向下查询 -> 查到 item.value !== null
  - 改: item.value
- 查 -> 从上向下查询 -> 查到 item.value !== null