# lesson 1-2 
## 算法的核心指标
- 时间
- 空间 
### 分析方法
- 大O表示法
## 什么是算法和数据结构
### 广义
- 数据结构就是指一组数据的存储结构。
- 算法就是操作数据的一组方法。
### 狭义
- 著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。
## 学习算法的好处
- 经典数据结构和算法都是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。
## 数据结构和算法的关系
- 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 两者是相辅相成的不可分隔
## 常见算法和数据结构
- 数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
- 递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。
## 学习目标
- 自身特点
- 适用于解决的问题
- 实际应用场景
- 来历
## 程序员内功
那技术人究竟都需要修炼哪些“内功”呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。
## 算法和数据结构分类
- 如何评价算法的好与坏
- 以数据结构为类,分散算法
  - 数据结构的来历,特点,适用场景
  - 数据结构的相关算法
    - 算法来历,特点
    - 与其他算法类似点.
    - 算法与数据结构 demo 代码
- 基本思想
# lesson 3 - 4 
## 算法解决的问题
- 数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。
## 时间空间复杂度分析
- 为了衡量算法的好与坏
- 复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。
## 为什么需要复杂度分析？
### 不使用复杂度分析
1. 我们可以通过把代码执行,监控.得到代码最后的准确时间和内存大小 .这种方法叫 "事后统计法".
### 复杂度分析要解决的问题
1. 测试结果非常依赖测试环境: 硬件的不同会对结果产生很大影响. i9 > i3 . 
2. 测试结果受数据规模的影响很大: 1000条数据 和 1000w条数据 制定的算法性能是不同的.
## 大 O 复杂度表示法
1. 假设 读数据-运算-写数据 的效率都一样 为 unit_time . 
2. 没一行代码执行都会使用1个 unit_time .
```Typescript
const l = [1,2,3,3,4,5,6,7,8,9,0]; // 1 unit_time
let result = 0; // 1 unit_time
for ( let i of l) {  // 1 unit_time * l.length
  result += l[i] // 1 unit_time * l.length
}
console.log(result) // 1 unit_time
// 总运行时间为 1 + 1 + 1 * l.length + 1 * l.length + 1
// 总结 代码的效率与 l.length 有关系 即 代码的效率 = l.length 的长度. l.length * 2
// 1 + 1 + 1 * n + 1 * n + 1 = 2n + 3
// 大O : T(n) = O(2n + 3)  => T(n) = O(2n) => T(n) = O(n)
```
```ts 
function cal(n:number) {
  let sum = 0 // 1
  let i = 1 ;  // 1
  let j = 1 ; // 1
  for ( ; i <= n ; ++i) { // 1 * n
    j = 1 ;  // 1 * n
    for(; j<= n ; ++j) { // 1 * n * n
      sum = sum + i * j ; // 1 * n * n
    }
  }
  return sum // 1
}
// 效率总和是  1 + 1 + 1 + 1 * n + 1 * n + 1 * n * n + 1 * n * n + 1
// 简化为 n * (2n + 2) + 4
// 大 O :T(n) = O(n * (2n + 2) + 4) => T(n) = O(n * (2n + 2)) => T(n) = O(n*n)
```
3. 例子中我们可以得到 整个代码的执行时间 和 执行次数成正比 T(n) = f(n) * 每行执行时间 
4. 得到公式 T(n) = O(f(n))
   1. T(n) 表示总执行时间
   2. n 表示执行数据规模
   3. O 表示执行一行数据的效率
   4. f(n) 表示每行执行的次数
5. 大 O 时间复杂度表示法,并不能确定代码运行的准确时间,但可以得到 数据规模增长的变化趋势 所以也叫 渐进时间复杂度（asymptotic time complexity），简称时间复杂度。
6. 因为 要描述 n 的趋势,所以 当 n 变化 恒定增加的 可以忽略 比如 2n 随着 n 变化只是恒定增加.而 n * n 会因为 n 的变化成几何倍数增加
### 分析方式
1. 只关注循环执行次数最多的一段代码 : 大 O 只关注 n 对代码的影响 与 代码的趋势,所以只需要关注有关于 n 的循环即可. 更简化可以只关注循环次数最多的 一段代码即可.
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度 . 抓大放小
  1. 例 1: 100 * n + n * n + 100 => 
     1. 忽略 常量 : T(n) = O(f(n * 100 + n * n))
     2. 当 n > 100 : T(n) = O (f(n * n))
     3. 当 n < 100 : T(n) = O (f(n * 100))
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积. 即循环套循环 = 循环次数  * 循环内的循环次数
  1. 例 1: 循环 n 次, T(n) = O(f(n))
  2. 例 2: 循环 n 次, 每次 循环 n 次  , T(n) = O(f(n) * f(n)) = O (f(n*n))
## 几种常见时间复杂度实例分析
### 多项式量级和非多项式量级
-  多项式量级 : 
   - 以 n 为底数
   - n 方大 算法性能增加 , 但性能比非多项式 好. 
-  非多项式量级:
   - n 不仅仅 可以做底数. 
   - n 放大 算法性能急剧增加
- 比较 n ^ 2 的性能 > n ^ n 的性能
###  常见时间复杂度实例
- 非多项式量级: O(2^n) 和 O(n!)
- 多项式量级:
  - O(1) : 指没有被重复执行的代码的效率 , 即使 是 10条代码, 也可以理解为是 O(1) 因为只执行 1 次
  - O(logn)、O(nlogn) :  
    - 解决的问题: 对数问题  n = 2 ^ x , n = 3 ^ x 的结果是 log(2)n , log(3)n 
    - log(2)n 和 log(3)n 效率如何比较 : log(3)n 比 log(2)n 效率高 . 因为 log(3)n = log(2)n * log(3)2
    - log(2)n 和 log(3)n 为什么都可以表示为 logn : 因为关注的只是 n 和效率的关系.所以 log(2) 和 log(3) 其实是常量的差别,不会对趋势造成影响.
  - O(m+n)、O(m*n)
    - 当有两组不定量时, m , n 这两组值时,我们无法确定 m > n or n < m 所以无法进行去掉不重要的处理. 但是可以通过 * 完成. T1(m) + T2(n) = O(f(m) + g(n)) ; t1(m) + t2(n) = O(f(m) * f(n))
## 空间复杂度分析
- 空间复杂度分析,主要看和 n 相关的代码即可 , 比如 创建一个 n 长的 数组. = O(n)
- 常见的空间有 O(1)、O(n)、O(n2 )
- 空间计算和时间计算是相同的.

## 复杂度 场景分析
一段代码在不同的场景下的复杂度是不一样的.比如 判断一个值在一个数组中的位置. 这个数在 0 和 n 的位置的效率是完全不同的.
### 最好情况复杂度
- 在最理想的情况下的复杂度,比如 判断值在数组中位置时,恰好值在第一个位置.
### 最坏情况复杂度
- 在最坏的情况下的复杂度,比如判断值在数组中位置时,值没有出现在数组中
### 平均情况复杂度
- 因为最好和最坏的情况发生的概率并不大, 所以想要表示平均情况, 需要使用新的概念.平均情况复杂度.
- 群举: 计算平均情况复杂度 = 所有次数 / 最大次数 = n (n + 3) / 2(n + 1)
- 概率统计(加权平均时间复杂度): 给每一个情况增加一个概率 然后统计出效率.具体效率
```ts
const array = new Array(n) ; 
const count = 0;
function insert(val:number) {
  if(count === array.length) {
    let sun = 0 ; 
    for (let i = 0 ; i < array.length ; ++i) {
      sum = sum + array[i];
    }
    array[0] = sum ;
    count = 1 
  }
  array[count] = val ;
  ++count
}
```
# 05 | 数组：为什么很多编程语言中数组都从0开始编号？
## 为什么数组要从 0 开始编号，而不是从 1 开始呢？
因为其实下标是用来移动内存的.第0个其实是移动 0 * 内存大小. 第二个值是 1 * 内存大小.
## 什么是数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
### 数组存储
1. 需要一组连续的内存空间
### 关键点
1. 线性表.
  1. `线性表`: 线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组，链表、队列、栈等也是线性表结构。
  2. `非线性表`: 比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。
2. 连续的内存空间和相同类型的数据.
### 优势
1. 随机访问
### 劣势
1. 删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。
2. 随机访问 可能会越界. 即下标不存在
### 工作
#### 创建
寻找一个内存块, 在内存块创建一个长度为10的空间, 内存会分配一个连续的10个的空间给数组.
#### 查询
例如下标是 i , 找到数组对应的内存块 . 用 i * 每个空间的大小. (base_address + i * data_type_size) 找到对应的空间.拿到对应的值.
#### 插入
在 k 的位置插入一个值
1. 将 k 位置腾出, 将 k 之后的数据 后挪.
2. 插入数据
3. 效率为 : O(n)
##### 块排思想
把 k 插入 n 的位置
1. 把 n 的位置内容取出
2. 把 k 插入 n 的位置
3. 把 n 插入 n + 1
4. 效率为 : O(n) , 但是数组旧的顺序被破坏.
#### 删除
把 n 位置的内容删除
1. 找到 n 位置 删除
2. 将 n 位置之后的内容前移1格
3. 效率为 O(n)
##### 标记清除垃圾回收算法
当我们要删除多个数据时候可以使用这种方案.
1. 直接删除 n 个数据
   1. 循环 n 
   2. 找到 第 n 个数据的位置
   3. 删除 数据
   4. 效率: O(n^2)
2. 标记删除 n 个数据
   1. 标记 n 个数据为废弃数据
   2. 创建新的数据.拷贝没有废弃的数据
   3. 替换数组
   4. 效率: O(n)
### 数组和其他类型结构的优势
1. 支持随机访问. 可以通过下标查值.
### 数组结构使用场景
1. 存在遍历的情况
# 06 | 链表（上）：如何实现LRU缓存淘汰算法?
## 链表有什么用
## LRU 缓存淘汰算法
LRU 策略是先进先出策略. 将最久的缓存删除. 所以设计使用单链表. 
1. 默认头节点为最新节点. 
2. 当查询缓存时,依次查询.
3. 查询到要使用的缓存时,将该缓存挪到头缓存.
4. 并删除当前位置缓存.
5. 如果有新缓存进入.判断是否有空间存放
   1. 有空间存放,直接插入头节点
   2. 无空间存放,删除尾节点,插入新缓存到头节点.
- 复杂度为O(n).
- 好处,使用最频繁的缓存,永远在最近的地方.而使用不频繁的缓存会慢慢的被删除.
## 链表的存储结构
1. 不需要连续的空间
2. 通过指针将一组数据串连起来.
## 链表常用结构
### 单链表
- 链表是由一个个 item 组成.
- 每个 item 有两个值 
  - data 数据本身 
  - next 下一个是谁
- 特殊 item
  - 第一个叫头节点 : 记录基地址,通过该节点可以比遍历整个链
  - 最后一个叫尾节点 : 指向 null , 表示链表结束
- 插入 , 删除 ,查找
  - 插入 :
    - 插入内容到某个节点的效率是 O(1) , 但是修改节点的上个节点的 next 效率是 O(n)
  - 删除 : 
    - 不需要移动所有节点只需要处理当时节点的 next 效率 O(1) 
    - 但是修改节点的上个节点的 next 效率是 O(n) 
  - 随机访问: 因为 链表不是有序存储,没有办法通过 下标 * 大小来找,只能遍历 n 个数据得到 ,效率 O(n)
### 循环链表
- 循环链表什么:循环列表与单列表结构基本相同.不同点在于尾节点. 单链表的尾节点指向 头节点. 首尾相连.
- 循环链表比单链表的好处是: 链表尾到链表头比较方便.如果数据具有环型结构特点时，就特别适合采用循环链表
- 经典使用场景:
  - 约瑟夫斯问题 : 有 一个环 有 n 个值, 从第一个值开始,每过两个值删除一个值, 直到剩下最后一个值.
### 双向链表
- 双向链表 和 单向链表的不同点在于 双相链表的 每一个 item 中多存放了一个 prev 记录上一个节点. 
- 双向链表 支持 双向遍历.
- 在存储相同多的数据时, 双向列表占用空间比单向列表多.
- 双向链表 比 单向列表的好处:
  - 以 O(1) 效率取到节点的前后节点.
  - 删除,修改: 给定节点位置时,删除该节点 . 效率只需要 O(1) 因为 知道上下节点 所以不需要查询
  - 查询: 在第一次查询时 记录 位置 P , 在第二次查询时候先通过 P 来判定向后还是向前. 然后 继续查询效率增加 .
## 思想
1. 以空间换时间, 以时间换空间.
2. 因场景来选择 时间重要还是空间重要 进行权衡. 例如缓存,即用空间换时间.
## 链表(双向链表) 和 数组对比
1. 链表 比 数组更耗费内存 , 且容易造成 内存碎片促发垃圾回收
2. 链表的 插入,删除 比数组快
3. 数组的 随机查询 比链表快.
4. 数组不支持动态扩容. ( JavaScript 数组设计)
## 字符串是否是回文字符串,字符串是通过单链表来存储的，那该如何来判断是一个回文串呢
https://leetcode.cn/problems/palindrome-linked-list/submissions/